/**
 * Schema Generator
 * Generates comprehensive schema.sql files for tables, columns, constraints, and indexes
 */

import { IntrospectionService } from '@/database/introspection';
import type {
  IColumnDefinition,
  IConstraintDefinition,
  IDatabaseConnection,
  IGeneratedFile,
  IGeneratorOptions,
  IIndexDefinition,
  ITableDefinition,
  TUnknownOrAny,
} from '@/types';
import type { Client } from 'pg';
import { BaseGenerator } from './baseGenerator';

export class SchemaGenerator extends BaseGenerator {
  private introspection: IntrospectionService;

  constructor(
    client: Client,
    connection: IDatabaseConnection,
    options: IGeneratorOptions
  ) {
    super(client, connection, options);
    this.introspection = new IntrospectionService(client, this.schema);
  }

  protected getGeneratorName(): string {
    return 'Schema Generator';
  }

  protected override shouldSkip(): boolean {
    return (
      (this.options.procsOnly ?? false) || (this.options.triggersOnly ?? false)
    );
  }

  protected override async validateData(): Promise<void> {
    const tables = await this.introspection.getTables();

    if (tables.length === 0) {
      throw new Error(`No tables found in schema '${this.schema}'`);
    }
  }

  async generate(): Promise<IGeneratedFile[]> {
    if (this.shouldSkip()) {
      return [];
    }

    await this.validateData();

    console.log('ðŸ“‹ Discovering tables and their metadata...');
    const tablesData = await this.introspection.getAllTablesComplete();

    console.log(`   Found ${tablesData.length} tables with complete metadata`);

    // Convert introspection data to generator types
    const tables = tablesData.map(this.convertToTableDefinition.bind(this));

    const content = await this.generateSchemaSQL(tables);

    return [
      {
        name: 'schema.sql',
        content: content,
      },
    ];
  }

  private async generateSchemaSQL(tables: ITableDefinition[]): Promise<string> {
    let sql = this.generateHeader(
      'SCHEMA DEFINITION',
      'Complete database schema including tables, columns, constraints, and indexes'
    );

    // Generate tables in dependency order (tables with foreign keys last)
    const sortedTables = this.sortTablesByDependencies(tables);

    for (const table of sortedTables) {
      sql += this.generateTableSQL(table);
    }

    sql += this.generateFooter();
    return sql;
  }

  private generateTableSQL(table: ITableDefinition): string {
    let sql = this.generateSectionHeader(
      `TABLE: ${table.schema}.${table.name}`
    );

    // Table comment
    if (table.comment) {
      sql += this.generateComment(`Table: ${table.comment}`) + '\n';
    }

    // CREATE TABLE statement
    sql += `CREATE TABLE ${this.escapeIdentifier(table.schema)}.${this.escapeIdentifier(table.name)} (\n`;

    // Columns
    const columnDefinitions = table.columns.map(col =>
      this.generateColumnDefinition(col)
    );

    sql += this.formatSQL(columnDefinitions.join(',\n'), 1) + '\n';

    sql += ');\n\n';

    // Table constraints (excluding column-level constraints)
    const tableConstraints = table.constraints.filter(
      constraint =>
        constraint.type !== 'NOT NULL' && constraint.type !== 'CHECK'
    );

    if (tableConstraints.length > 0) {
      sql += this.generateComment('Table constraints') + '\n';

      for (const constraint of tableConstraints) {
        sql +=
          this.generateConstraintSQL(constraint, table.schema, table.name) +
          '\n';
      }

      sql += '\n';
    }

    // Indexes
    if (table.indexes.length > 0) {
      sql += this.generateComment('Indexes') + '\n';

      for (const index of table.indexes) {
        sql += this.generateIndexSQL(index, table.schema) + '\n';
      }

      sql += '\n';
    }

    return sql;
  }

  private generateColumnDefinition(column: IColumnDefinition): string {
    let definition = `${this.escapeIdentifier(column.name)} ${this.generateDataType(column)}`;

    // NOT NULL constraint
    if (!column.nullable) {
      definition += ' NOT NULL';
    }

    // DEFAULT value
    if (column.defaultValue) {
      definition += ` DEFAULT ${column.defaultValue}`;
    }

    // Identity column
    if (column.isIdentity) {
      if (column.identityGeneration === 'ALWAYS') {
        definition += ' GENERATED ALWAYS AS IDENTITY';
      } else if (column.identityGeneration === 'BY DEFAULT') {
        definition += ' GENERATED BY DEFAULT AS IDENTITY';
      }
    }

    // Generated column
    if (column.generated && column.generated !== 'NEVER') {
      definition += ` GENERATED ${column.generated}`;
    }

    return definition;
  }

  private generateDataType(column: IColumnDefinition): string {
    let type = column.type.toUpperCase();

    // Add length/precision for character types
    if (column.length && (type.includes('CHAR') || type.includes('VARCHAR'))) {
      type += `(${column.length})`;
    }

    // Add precision and scale for numeric types
    if (column.precision !== undefined) {
      if (column.scale !== undefined) {
        type += `(${column.precision},${column.scale})`;
      } else {
        type += `(${column.precision})`;
      }
    }

    return type;
  }

  private convertToTableDefinition(data: {
    table: TUnknownOrAny;
    columns: TUnknownOrAny[];
    constraints: TUnknownOrAny[];
    indexes: TUnknownOrAny[];
  }): ITableDefinition {
    return {
      name: data.table.table_name,
      schema: data.table.table_schema,
      columns: data.columns.map(this.convertToColumnDefinition.bind(this)),
      constraints: data.constraints.map(
        this.convertToConstraintDefinition.bind(this)
      ),
      indexes: data.indexes.map(this.convertToIndexDefinition.bind(this)),
      comment: data.table.table_comment ?? undefined,
    };
  }

  private convertToColumnDefinition(column: TUnknownOrAny): IColumnDefinition {
    return {
      name: column.column_name,
      type: column.data_type,
      nullable: column.is_nullable === 'YES',
      defaultValue: column.column_default ?? undefined,
      length: column.character_maximum_length ?? undefined,
      precision: column.numeric_precision ?? undefined,
      scale: column.numeric_scale ?? undefined,
      isIdentity: column.is_identity === 'YES',
      identityGeneration: column.identity_generation as
        | 'ALWAYS'
        | 'BY DEFAULT'
        | undefined,
      generated: column.is_generated as
        | 'ALWAYS'
        | 'BY DEFAULT'
        | 'NEVER'
        | undefined,
    };
  }

  private convertToConstraintDefinition(
    constraint: TUnknownOrAny
  ): IConstraintDefinition {
    return {
      name: constraint.constraint_name,
      type: constraint.constraint_type,
      columns: constraint.column_names
        ? constraint.column_names.split(',')
        : [],
      references: constraint.foreign_table_name
        ? {
            table: constraint.foreign_table_name,
            column: constraint.foreign_column_name ?? 'id',
          }
        : undefined,
      checkClause: constraint.check_clause ?? undefined,
      deferrable: constraint.is_deferrable === 'YES',
      initiallyDeferred: constraint.initially_deferred === 'YES',
      onDelete: constraint.delete_rule,
      onUpdate: constraint.update_rule,
    };
  }

  private convertToIndexDefinition(index: TUnknownOrAny): IIndexDefinition {
    return {
      name: index.indexname,
      table: index.tablename,
      columns: index.column_names ? index.column_names.split(',') : [],
      unique: index.is_unique === 'YES',
      partial: index.partial_condition ?? undefined,
      method: index.index_method ?? 'btree',
    };
  }

  private generateConstraintSQL(
    constraint: IConstraintDefinition,
    schema: string,
    tableName: string
  ): string {
    const constraintName = this.escapeIdentifier(constraint.name);
    const tableRef = `${this.escapeIdentifier(schema)}.${this.escapeIdentifier(tableName)}`;
    const columns = constraint.columns
      .map(col => this.escapeIdentifier(col))
      .join(', ');

    switch (constraint.type) {
      case 'PRIMARY KEY': {
        return `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} PRIMARY KEY (${columns});`;
      }

      case 'UNIQUE': {
        return `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} UNIQUE (${columns});`;
      }

      case 'FOREIGN KEY': {
        if (!constraint.references) {
          return `-- TODO: Foreign key constraint ${constraintName} - missing reference information`;
        }
        const refTable = this.escapeIdentifier(constraint.references.table);
        const refColumn = this.escapeIdentifier(constraint.references.column);
        let fkSQL = `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} FOREIGN KEY (${columns}) REFERENCES ${refTable} (${refColumn})`;

        if (constraint.onDelete) {
          fkSQL += ` ON DELETE ${constraint.onDelete}`;
        }
        if (constraint.onUpdate) {
          fkSQL += ` ON UPDATE ${constraint.onUpdate}`;
        }
        if (constraint.deferrable) {
          fkSQL += ' DEFERRABLE';
          if (constraint.initiallyDeferred) {
            fkSQL += ' INITIALLY DEFERRED';
          }
        }
        fkSQL += ';';
        return fkSQL;
      }

      case 'CHECK': {
        const checkClause =
          constraint.checkClause ?? '/* TODO: Add check condition */';
        return `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} CHECK (${checkClause});`;
      }

      default: {
        return `-- TODO: Unsupported constraint type: ${constraint.type}`;
      }
    }
  }

  private generateIndexSQL(index: IIndexDefinition, schema: string): string {
    const indexName = this.escapeIdentifier(index.name);
    const tableName = this.escapeIdentifier(index.table);
    const columns = index.columns
      .map(col => this.escapeIdentifier(col))
      .join(', ');

    let sql = `CREATE`;

    if (index.unique) {
      sql += ` UNIQUE`;
    }

    sql += ` INDEX ${indexName} ON ${this.escapeIdentifier(schema)}.${tableName}`;

    if (index.method && index.method !== 'btree') {
      sql += ` USING ${index.method}`;
    }

    sql += ` (${columns})`;

    if (index.partial) {
      sql += ` WHERE ${index.partial}`;
    }

    sql += ';';

    return sql;
  }

  private sortTablesByDependencies(
    tables: ITableDefinition[]
  ): ITableDefinition[] {
    const sorted: ITableDefinition[] = [];
    const visited = new Set<string>();
    const visiting = new Set<string>();

    const visit = (table: ITableDefinition) => {
      if (visiting.has(table.name)) {
        // Circular dependency detected - add anyway
        return;
      }

      if (visited.has(table.name)) {
        return;
      }

      visiting.add(table.name);

      // Find tables this table depends on (via foreign keys)
      const dependencies = tables.filter(
        otherTable =>
          otherTable.name !== table.name &&
          table.constraints.some(
            constraint =>
              constraint.type === 'FOREIGN KEY' &&
              constraint.references?.table === otherTable.name
          )
      );

      // Visit dependencies first
      for (const dep of dependencies) {
        visit(dep);
      }

      visiting.delete(table.name);
      visited.add(table.name);
      sorted.push(table);
    };

    for (const table of tables) {
      visit(table);
    }

    return sorted;
  }
}
