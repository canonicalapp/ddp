/**
 * Schema Generator
 * Generates comprehensive schema.sql files for tables, columns, constraints, and indexes
 */

import { IntrospectionService } from '@/database/introspection';
import type {
  IColumnDefinition,
  IConstraintDefinition,
  IDatabaseConnection,
  IGeneratedFile,
  IGeneratorOptions,
  IIndexDefinition,
  ITableDefinition,
  TUnknownOrAny,
} from '@/types';
import type { Client } from 'pg';
import { BaseGenerator } from './baseGenerator';

export class SchemaGenerator extends BaseGenerator {
  private introspection: IntrospectionService;

  constructor(
    client: Client,
    connection: IDatabaseConnection,
    options: IGeneratorOptions
  ) {
    super(client, connection, options);
    this.introspection = new IntrospectionService(client, this.schema);
  }

  protected getGeneratorName(): string {
    return 'Schema Generator';
  }

  protected override shouldSkip(): boolean {
    return (
      (this.options.procsOnly ?? false) || (this.options.triggersOnly ?? false)
    );
  }

  protected override async validateData(): Promise<void> {
    const tables = await this.introspection.getTables();

    if (tables.length === 0) {
      throw new Error(`No tables found in schema '${this.schema}'`);
    }
  }

  async generate(): Promise<IGeneratedFile[]> {
    if (this.shouldSkip()) {
      return [];
    }

    await this.validateData();

    console.log('ðŸ“‹ Discovering tables and their metadata...');
    const tablesData = await this.introspection.getAllTablesComplete();

    console.log(`   Found ${tablesData.length} tables with complete metadata`);

    // Convert introspection data to generator types
    const tables = tablesData.map(this.convertToTableDefinition.bind(this));

    const content = await this.generateSchemaSQL(tables);

    return [
      {
        name: 'schema.sql',
        content: content,
      },
    ];
  }

  private async generateSchemaSQL(tables: ITableDefinition[]): Promise<string> {
    let sql = this.generateHeader(
      'SCHEMA DEFINITION',
      'Complete database schema including tables, columns, constraints, and indexes'
    );

    // Generate tables in alphabetical order (as per DDP specification)
    const sortedTables = this.sortTablesAlphabetically(tables);

    for (const table of sortedTables) {
      sql += this.generateTableSQL(table);
    }

    sql += this.generateFooter();
    return sql;
  }

  private generateTableSQL(table: ITableDefinition): string {
    let sql = this.generateSectionHeader(
      `TABLE: ${table.schema}.${table.name}`
    );

    // Table comment
    if (table.comment) {
      sql += this.generateComment(`Table: ${table.comment}`) + '\n';
    }

    // CREATE TABLE statement
    sql += `CREATE TABLE ${this.escapeIdentifier(table.schema)}.${this.escapeIdentifier(table.name)} (\n`;

    // Columns (ensure ordinal order as per CID specification)
    const sortedColumns = [...table.columns].sort(
      (a, b) => a.ordinalPosition - b.ordinalPosition
    );
    const columnDefinitions = sortedColumns.map(col =>
      this.generateColumnDefinition(col)
    );

    sql += this.formatSQL(columnDefinitions.join(',\n'), 1) + '\n';

    sql += ');\n\n';

    // Table constraints (excluding column-level constraints)
    const tableConstraints = table.constraints.filter(
      constraint =>
        constraint.type !== 'NOT NULL' && constraint.type !== 'CHECK'
    );

    if (tableConstraints.length > 0) {
      sql += this.generateComment('Table constraints') + '\n';

      for (const constraint of tableConstraints) {
        sql +=
          this.generateConstraintSQL(constraint, table.schema, table.name) +
          '\n';
      }

      sql += '\n';
    }

    // Indexes
    if (table.indexes.length > 0) {
      sql += this.generateComment('Indexes') + '\n';

      for (const index of table.indexes) {
        sql += this.generateIndexSQL(index, table.schema) + '\n';
      }

      sql += '\n';
    }

    return sql;
  }

  private generateColumnDefinition(column: IColumnDefinition): string {
    let definition = `${this.escapeIdentifier(column.name)} ${this.generateDataType(column)}`;

    // NOT NULL constraint (only if not nullable - default is nullable)
    if (!column.nullable) {
      definition += ' NOT NULL';
    }

    // DEFAULT value (only if explicitly set and not a default default)
    if (
      column.defaultValue &&
      !this.isDefaultDefaultValue(column.defaultValue)
    ) {
      definition += ` DEFAULT ${column.defaultValue}`;
    }

    // Identity column (only if explicitly set)
    if (column.isIdentity) {
      if (column.identityGeneration === 'ALWAYS') {
        definition += ' GENERATED ALWAYS AS IDENTITY';
      } else if (column.identityGeneration === 'BY DEFAULT') {
        definition += ' GENERATED BY DEFAULT AS IDENTITY';
      }
    }

    // Generated column (only if not NEVER - which is the default)
    if (column.generated && column.generated !== 'NEVER') {
      definition += ` GENERATED ${column.generated}`;
    }

    return definition;
  }

  /**
   * Check if a default value is a "default default" that should be omitted
   * @param defaultValue - The default value to check
   * @returns true if this is a default default value that should be omitted
   */
  private isDefaultDefaultValue(defaultValue: string): boolean {
    const defaultDefaults = [
      'NULL',
      'null',
      'DEFAULT NULL',
      'default null',
      '::text',
      '::character varying',
      '::integer',
      '::bigint',
      '::numeric',
      '::boolean',
      '::timestamp without time zone',
      '::timestamp with time zone',
      '::date',
      '::time without time zone',
      '::time with time zone',
    ];

    return defaultDefaults.some(defaultVal =>
      defaultValue.toLowerCase().includes(defaultVal.toLowerCase())
    );
  }

  private generateDataType(column: IColumnDefinition): string {
    let type = column.type.toUpperCase();

    // Add length/precision for character types (only if not default)
    if (column.length && (type.includes('CHAR') || type.includes('VARCHAR'))) {
      // Only add length if it's not a default length
      if (!this.isDefaultLength(type, column.length)) {
        type += `(${column.length})`;
      }
    }

    // Add precision and scale for numeric types (only if not default)
    if (column.precision !== undefined) {
      if (column.scale !== undefined) {
        // Only add precision/scale if they're not defaults
        if (
          !this.isDefaultNumericPrecision(type, column.precision, column.scale)
        ) {
          type += `(${column.precision},${column.scale})`;
        }
      } else {
        // Only add precision if it's not a default
        if (!this.isDefaultNumericPrecision(type, column.precision, 0)) {
          type += `(${column.precision})`;
        }
      }
    }

    return type;
  }

  /**
   * Check if a character length is a default that should be omitted
   * @param type - The data type
   * @param length - The length value
   * @returns true if this is a default length that should be omitted
   */
  private isDefaultLength(type: string, length: number): boolean {
    // Common default lengths that should be omitted
    const defaultLengths: { [key: string]: number } = {
      VARCHAR: 255,
      CHAR: 1,
      'CHARACTER VARYING': 255,
      CHARACTER: 1,
      TEXT: 0, // TEXT doesn't need length specification
    };

    return defaultLengths[type] === length;
  }

  /**
   * Check if numeric precision/scale are defaults that should be omitted
   * @param type - The data type
   * @param precision - The precision value
   * @param scale - The scale value
   * @returns true if these are default values that should be omitted
   */
  private isDefaultNumericPrecision(
    type: string,
    precision: number,
    scale: number
  ): boolean {
    // Common default precisions that should be omitted
    const defaultPrecisions: {
      [key: string]: { precision: number; scale: number };
    } = {
      INTEGER: { precision: 32, scale: 0 },
      BIGINT: { precision: 64, scale: 0 },
      SMALLINT: { precision: 16, scale: 0 },
      NUMERIC: { precision: 0, scale: 0 }, // Default numeric without precision
      DECIMAL: { precision: 0, scale: 0 }, // Default decimal without precision
    };

    const defaultPrecision = defaultPrecisions[type];
    return !!(
      defaultPrecision &&
      defaultPrecision.precision === precision &&
      defaultPrecision.scale === scale
    );
  }

  private convertToTableDefinition(data: {
    table: TUnknownOrAny;
    columns: TUnknownOrAny[];
    constraints: TUnknownOrAny[];
    indexes: TUnknownOrAny[];
  }): ITableDefinition {
    return {
      name: data.table.table_name,
      schema: data.table.table_schema,
      columns: data.columns.map(this.convertToColumnDefinition.bind(this)),
      constraints: data.constraints.map(
        this.convertToConstraintDefinition.bind(this)
      ),
      indexes: data.indexes.map(this.convertToIndexDefinition.bind(this)),
      comment: data.table.table_comment ?? undefined,
    };
  }

  private convertToColumnDefinition(column: TUnknownOrAny): IColumnDefinition {
    return {
      name: column.column_name,
      type: column.data_type,
      nullable: column.is_nullable === 'YES',
      defaultValue: column.column_default ?? undefined,
      length: column.character_maximum_length ?? undefined,
      precision: column.numeric_precision ?? undefined,
      scale: column.numeric_scale ?? undefined,
      isIdentity: column.is_identity === 'YES',
      identityGeneration: column.identity_generation as
        | 'ALWAYS'
        | 'BY DEFAULT'
        | undefined,
      generated: column.is_generated as
        | 'ALWAYS'
        | 'BY DEFAULT'
        | 'NEVER'
        | undefined,
      ordinalPosition: column.ordinal_position ?? 0,
    };
  }

  private convertToConstraintDefinition(
    constraint: TUnknownOrAny
  ): IConstraintDefinition {
    return {
      name: constraint.constraint_name,
      type: constraint.constraint_type,
      columns: constraint.column_names
        ? constraint.column_names.split(',')
        : [],
      references: constraint.foreign_table_name
        ? {
            table: constraint.foreign_table_name,
            column: constraint.foreign_column_name ?? 'id',
          }
        : undefined,
      checkClause: constraint.check_clause ?? undefined,
      deferrable: constraint.is_deferrable === 'YES',
      initiallyDeferred: constraint.initially_deferred === 'YES',
      onDelete: constraint.delete_rule,
      onUpdate: constraint.update_rule,
    };
  }

  private convertToIndexDefinition(index: TUnknownOrAny): IIndexDefinition {
    return {
      name: index.indexname,
      table: index.tablename,
      columns: index.column_names ? index.column_names.split(',') : [],
      unique: index.is_unique === 'YES',
      partial: index.partial_condition ?? undefined,
      method: index.index_method ?? 'btree',
    };
  }

  private generateConstraintSQL(
    constraint: IConstraintDefinition,
    schema: string,
    tableName: string
  ): string {
    const constraintName = this.escapeIdentifier(constraint.name);
    const tableRef = `${this.escapeIdentifier(schema)}.${this.escapeIdentifier(tableName)}`;
    const columns = constraint.columns
      .map(col => this.escapeIdentifier(col))
      .join(', ');

    switch (constraint.type) {
      case 'PRIMARY KEY': {
        return `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} PRIMARY KEY (${columns});`;
      }

      case 'UNIQUE': {
        return `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} UNIQUE (${columns});`;
      }

      case 'FOREIGN KEY': {
        if (!constraint.references) {
          return `-- TODO: Foreign key constraint ${constraintName} - missing reference information`;
        }
        const refTable = this.escapeIdentifier(constraint.references.table);
        const refColumn = this.escapeIdentifier(constraint.references.column);
        let fkSQL = `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} FOREIGN KEY (${columns}) REFERENCES ${refTable} (${refColumn})`;

        if (constraint.onDelete) {
          fkSQL += ` ON DELETE ${constraint.onDelete}`;
        }
        if (constraint.onUpdate) {
          fkSQL += ` ON UPDATE ${constraint.onUpdate}`;
        }
        if (constraint.deferrable) {
          fkSQL += ' DEFERRABLE';
          if (constraint.initiallyDeferred) {
            fkSQL += ' INITIALLY DEFERRED';
          }
        }
        fkSQL += ';';
        return fkSQL;
      }

      case 'CHECK': {
        const checkClause =
          constraint.checkClause ?? '/* TODO: Add check condition */';
        return `ALTER TABLE ${tableRef} ADD CONSTRAINT ${constraintName} CHECK (${checkClause});`;
      }

      default: {
        return `-- TODO: Unsupported constraint type: ${constraint.type}`;
      }
    }
  }

  private generateIndexSQL(index: IIndexDefinition, schema: string): string {
    const indexName = this.escapeIdentifier(index.name);
    const tableName = this.escapeIdentifier(index.table);
    const columns = index.columns
      .map(col => this.escapeIdentifier(col))
      .join(', ');

    let sql = `CREATE`;

    if (index.unique) {
      sql += ` UNIQUE`;
    }

    sql += ` INDEX ${indexName} ON ${this.escapeIdentifier(schema)}.${tableName}`;

    if (index.method && index.method !== 'btree') {
      sql += ` USING ${index.method}`;
    }

    sql += ` (${columns})`;

    if (index.partial) {
      sql += ` WHERE ${index.partial}`;
    }

    sql += ';';

    return sql;
  }

  private sortTablesAlphabetically(
    tables: ITableDefinition[]
  ): ITableDefinition[] {
    return [...tables].sort((a, b) => a.name.localeCompare(b.name));
  }

  private sortTablesByDependencies(
    tables: ITableDefinition[]
  ): ITableDefinition[] {
    const sorted: ITableDefinition[] = [];
    const visited = new Set<string>();
    const visiting = new Set<string>();

    const visit = (table: ITableDefinition) => {
      if (visiting.has(table.name)) {
        // Circular dependency detected - add anyway
        return;
      }

      if (visited.has(table.name)) {
        return;
      }

      visiting.add(table.name);

      // Find tables this table depends on (via foreign keys)
      const dependencies = tables.filter(
        otherTable =>
          otherTable.name !== table.name &&
          table.constraints.some(
            constraint =>
              constraint.type === 'FOREIGN KEY' &&
              constraint.references?.table === otherTable.name
          )
      );

      // Visit dependencies first
      for (const dep of dependencies) {
        visit(dep);
      }

      visiting.delete(table.name);
      visited.add(table.name);
      sorted.push(table);
    };

    for (const table of tables) {
      visit(table);
    }

    return sorted;
  }
}
