/**
 * Column Builder
 * Handles column definition generation and data type utilities
 */

import type { IColumnInfo } from '@/database/introspection';
import type { IColumnDefinition } from '@/types';

export class ColumnBuilder {
  /**
   * Convert introspection column data to column definition
   */
  convertToColumnDefinition(column: IColumnInfo): IColumnDefinition {
    return {
      name: column.column_name,
      type: column.data_type,
      nullable: column.is_nullable === 'YES',
      ...(column.column_default && { defaultValue: column.column_default }),
      ...(column.character_maximum_length && {
        length: column.character_maximum_length,
      }),
      ...(column.numeric_precision && { precision: column.numeric_precision }),
      ...(column.numeric_scale && { scale: column.numeric_scale }),
      isIdentity: column.is_identity === 'YES',
      identityGeneration: column.identity_generation as
        | 'ALWAYS'
        | 'BY DEFAULT'
        | undefined,
      generated: column.is_generated as
        | 'ALWAYS'
        | 'BY DEFAULT'
        | 'NEVER'
        | undefined,
      generationExpression: column.generation_expression,
      ordinalPosition: column.ordinal_position || 0,
    };
  }

  /**
   * Generate column definition SQL
   */
  generateColumnDefinition(column: IColumnDefinition): string {
    let definition = `${this.escapeIdentifier(column.name)} ${this.generateDataType(column)}`;

    // NOT NULL constraint (only if not nullable - default is nullable)
    if (!column.nullable) {
      definition += ' NOT NULL';
    }

    // DEFAULT value (only if explicitly set and not a default default)
    if (
      column.defaultValue &&
      !this.isDefaultDefaultValue(column.defaultValue)
    ) {
      definition += ` DEFAULT ${column.defaultValue}`;
    }

    // Identity column (only if explicitly set)
    if (column.isIdentity) {
      if (column.identityGeneration === 'ALWAYS') {
        definition += ' GENERATED ALWAYS AS IDENTITY';
      } else if (column.identityGeneration === 'BY DEFAULT') {
        definition += ' GENERATED BY DEFAULT AS IDENTITY';
      }
    }

    // Generated column (only if not NEVER - which is the default)
    if (column.generated && column.generated !== 'NEVER') {
      if (column.generationExpression) {
        definition += ` GENERATED ${column.generated} AS (${column.generationExpression}) STORED`;
      } else {
        definition += ` GENERATED ${column.generated}`;
      }
    }

    return definition;
  }

  /**
   * Generate data type string for column
   */
  private generateDataType(column: IColumnDefinition): string {
    let type = column.type.toUpperCase();

    // Add length/precision for character types (only if not default)
    if (column.length && (type.includes('CHAR') || type.includes('VARCHAR'))) {
      // Only add length if it's not a default length
      if (!this.isDefaultLength(type, column.length)) {
        type += `(${column.length})`;
      }
    }

    // Add precision and scale for numeric types (only if not default)
    if (column.precision !== undefined) {
      if (column.scale !== undefined) {
        // Only add precision/scale if they're not defaults
        if (
          !this.isDefaultNumericPrecision(type, column.precision, column.scale)
        ) {
          type += `(${column.precision},${column.scale})`;
        }
      } else {
        // Only add precision if it's not a default
        if (!this.isDefaultNumericPrecision(type, column.precision, 0)) {
          type += `(${column.precision})`;
        }
      }
    }

    return type;
  }

  /**
   * Check if a default value is a "default default" that should be omitted
   */
  private isDefaultDefaultValue(defaultValue: string): boolean {
    const defaultDefaults = [
      'NULL',
      'null',
      'DEFAULT NULL',
      'default null',
      '::text',
      '::character varying',
      '::integer',
      '::bigint',
      '::numeric',
      '::boolean',
      '::timestamp without time zone',
      '::timestamp with time zone',
      '::date',
      '::time without time zone',
      '::time with time zone',
    ];

    return defaultDefaults.some(defaultVal =>
      defaultValue.toLowerCase().includes(defaultVal.toLowerCase())
    );
  }

  /**
   * Check if a character length is a default that should be omitted
   */
  private isDefaultLength(type: string, length: number): boolean {
    // Common default lengths that should be omitted
    const defaultLengths: { [key: string]: number } = {
      VARCHAR: 255,
      CHAR: 1,
      'CHARACTER VARYING': 255,
      CHARACTER: 1,
      TEXT: 0, // TEXT doesn't need length specification
    };

    return defaultLengths[type] === length;
  }

  /**
   * Check if numeric precision/scale are defaults that should be omitted
   */
  private isDefaultNumericPrecision(
    type: string,
    precision: number,
    scale: number
  ): boolean {
    // Common default precisions that should be omitted
    const defaultPrecisions: {
      [key: string]: { precision: number; scale: number };
    } = {
      INTEGER: { precision: 32, scale: 0 },
      BIGINT: { precision: 64, scale: 0 },
      SMALLINT: { precision: 16, scale: 0 },
      NUMERIC: { precision: 0, scale: 0 }, // Default numeric without precision
      DECIMAL: { precision: 0, scale: 0 }, // Default decimal without precision
    };

    const defaultPrecision = defaultPrecisions[type];

    return !!(
      defaultPrecision &&
      defaultPrecision.precision === precision &&
      defaultPrecision.scale === scale
    );
  }

  /**
   * Escape identifier for SQL
   */
  private escapeIdentifier(identifier: string): string {
    return `"${identifier.replace(/"/g, '""')}"`;
  }
}
